### QT 模块化/插件 开发

- 动态库的装载（指导入进程空间，然后执行）方式比可执行文件的装载稍微复杂，因为它把模块链接过程推迟到了运行时。

> 在动态链接库的装载过程中，首要任务就是解决地址重定向问题。我们知道，DLL装载到进程空间的位置（基址）是不确定的（动态装载嘛），即使DLL内部使用的函数调用和全局变量引用，在装载时都要重新计算其地址。Windows采用基址重定向（Rebasing）技术解决这一问题，而Linux采用地址无关代码（PIC，通过GOT和PLT表实现）技术。这两种技术各有优缺点。

- QT使用以下两个宏来实现符号（函数或全局变量/对象）的导出和导入（跨平台不能用def文件了）：

    - Q_DECL_EXPORT   // 必须添加到符号声明中（共享库项目）
    - Q_DECL_IMPORT   // 必须添加到符号声明中（使用共享库的客户项目）

QT使用 QLibrary 类实现共享库的动态加载，即在运行时决定加载那个DLL程序，插件机制使用。

#### QT 模块化示例

    - Bil 项目：共享库项目，输出Bil.dll和Bil.lib，基础接口类库，定义一个公共的接口IAnimal（抽象类），供客户项目和插件项目使用；
    - Plugin 类项目：插件类项目，现编写BilDog和BilPanda两插件项目，实现IAnimal的功能，供客户项目加载和测试。两项目输出BilDog.dll和BilPanda.dll；
    - Test 项目：客户应用程序项目，输出Test.exe，界面中可以选择要加载的Animal插件，然后调用Animal的功能函数，完成测试；

> 示例代码

使用BIL_SHARE宏，我们只需要向Animal插件的开发者提供同一份IAnimal定义文件（IAnimal.h）即可。
当然，我们得先在Bil项目的编译选项中定义BIL_LIB宏，使得在Bil项目内，BIL_SHARE就是导出符号的声明。插件项目就不要定义BIL_LIB了，因为在Animal插件项目中，IAnimal是导入符号。
QT工程文件Bil.pro中加入如下定义(在Bil项目的编译选项中定义BIL_LIB宏)：

DEFINES += BIL_LIB

虽然只实现了构造和析构函数，并且什么工作也不做，但这是必要的，我们暂时不要使用内联的构造和析构函数，否则在插件项目实现IAnimal时可能会出现链接错误。

好了，我们开始编译吧，生成整个Bil项目。最终我们得到两个输出文件：Bil.lib 和 Bil.dll。我们向Animal插件开发者提供：
    - 两个头文件：Bil.h 和 IAnimal.h
    - 两个库文件：Bil.lib 和 Bil.dll
下面的插件类项目和客户项目就是依赖这些文件实现的，也许你更愿意把Bil看作是一个通用的DLL类库，就像QT或MFC一样——事实上也是如此，Bil就是这样一个动态的共享类库。

编写Animal插件 —— BilDog 和 BilPanda 插件


3. 编写客户程序——调用插件


#### dll 问题

1. 版本控制不好：DLL是共享的，如果某程序更新了一个共享的DLL，其它同样依赖于该DLL的程序就可能不能正常工作了！
2. 兼容问题：即使同一平台，不同编译器（甚至同一编译器的不同版本）编出来的共享库和程序也可能不能协同工作。

> 二制兼容问题对于C++来说尤其严重。C++的标准是源代码级别的，标准中并没有对如何实现C++作出统一的规定，所以不同的编译器，对标准C++采用不
同的实现方式。这些差异主要有：对象在内存中的分配（C++）、构造和析构函数的实现（C++）、重载和模板的实现（C++）、虚函数表结构（C++）、
多重继承和虚基类的实现（C++）、函数调用约定（C）、符号修饰（C/C++）等。此外，不同的运行时库（CRT、STL等标准库）也会引起ABI兼容
问题。可以说，如果你在编写基于类的共享库，如果接口（指导出类）稍有改变，新的DLL与原程序就可能不协同工作了。

### 执行过程

1. 先去build1下执行，然后创建软链接到 /lib 再执行ldconf
2. 再去build2下执行
3. 最后编译执行main
